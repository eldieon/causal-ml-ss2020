import copy

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import statsmodels.api as sm
from IPython.display import display
from causalml.metrics import *
from mlens.ensemble import SuperLearner
from sklearn.metrics import mean_squared_error

import simple_model


def do_stacking(predictions_dict, true_te):
    """
    :param predictions_dict: dict of predictions (genereated from simple_model.make_simple_predictions_for_stacking)
    :param true_te: the treatment effect provided with the causalml.datasets synthetic data generators

    :return: a dict of params.
    """
    pd = copy.deepcopy(predictions_dict)
    pd.pop('Actuals')
    pd.pop('generated_data')

    x_stacking = np.vstack((pd.values())).T

    model = sm.OLS(true_te, x_stacking)
    model2 = model.fit_regularized(alpha=0.0, L1_wt=1.0, start_params=None, profile_scale=False, refit=False)
    return model2


def do_stacking_simple_models(regressors, X, y, w, meta):
    """
    do stacking witht the mlens library.

    :param regressors: a dict of regressors to feed into the ensemble pipeline
    :param X: training dataset
    :param y: outcome varaible y
    :param w: assignment variable
    :param meta: regressor (found in regressors dict for ensemble)

    :return: CATE predictions from the ensemble estimator
    """

    ensemble = SuperLearner(scorer=mean_squared_error, random_state=42)
    ensemble.add([x for x in regressors.values()])
    ensemble.add_meta(regressors[meta])

    e_preds, tau_test = simple_model.create_simple_ml_model(X, y, w, ensemble)

    return e_preds


def plot_stacking_preds(model, true_te):
    """
    :param model:
    :param true_te:
    :return: plot a matplotlib.pyplot plot (histogram of predictions compared to the true treatment effect.)
    """
    alpha = 0.4
    bins = 20

    stacking_fitted_vals = model.fittedvalues
    weights = model.params

    plt.hist(stacking_fitted_vals, alpha=alpha, bins=bins, label='predicted values (stacking)')
    plt.hist(true_te, alpha=alpha, bins=bins, label='true treatment effect')

    plt.axis([-10, 10, 0, 200])
    plt.title('predictions made by tacking model, vs true treatment effect')
    plt.xlabel('Individual Treatment Effect (ITE/CATE)')
    plt.ylabel('# of Samples')
    _ = plt.legend()
    plt.show()


def evaluate_models_compare_to_stacking_mse(predictions_dict, true_treatment_effect, stacking_predictions):
    """
    :param predictions_dict: dict of predictions of treatment effect
    :param true_treatment_effect:
    :param stacking_predictions: an array of predicitons given by the stacking model
    :return: a table/array of evaluation metrics for each model
    """

    pd = copy.deepcopy(predictions_dict)
    if "Actuals" in predictions_dict:
        pd.pop('Actuals')
    if "generated_data" in predictions_dict:
        pd.pop('generated_data')

    mse_dict = {}
    for key in pd.keys():
        mse_dict[key] = mean_squared_error(true_treatment_effect, pd[key])

    mse_dict['stacking'] = mean_squared_error(true_treatment_effect, stacking_predictions)
    return mse_dict


def evaluate_models_compare_to_stacking_r_square(predictions_dict, true_treatment_effect, stacking_predictions):
    """
    :param predictions_dict:
    :param true_treatment_effect:
    :param stacking_predictions: an array of predicitons given by the stacking model
    :return: a table/array of evaluation metrics for each model
    """

    pd = copy.deepcopy(predictions_dict)
    if "Actuals" in predictions_dict:
        pd.pop('Actuals')
    if "generated_data" in predictions_dict:
        pd.pop('generated_data')

    r2_dict = {}
    for key in pd.keys():
        r2_dict[key] = r2_score(true_treatment_effect, pd[key])

    r2_dict['stacking'] = r2_score(true_treatment_effect, stacking_predictions)
    return r2_dict


def show_MSE_r_square(indv_predictions, tau_test, ensemble_predictions, rsq=False):
    """
    :param indv_predictions: dict of predicted treatmenet effects from individual, somple models
    :param tau_test: true treatment effect (corresponding to predictions of indv_predictions)
    :param ensemble_predictions: predicted treatmenet effect of the ensemble
    :param rsq: compute and show r square. often unhelpful metric.
    :return: visualize a table of mse and R squared.
    """

    mseDict = evaluate_models_compare_to_stacking_mse(indv_predictions, tau_test, ensemble_predictions)
    mseDf = pd.DataFrame(mseDict, index=['MSE', ])

    if rsq == True:
        r2Dict = evaluate_models_compare_to_stacking_r_square(indv_predictions, tau_test, ensemble_predictions)
        r2DF = pd.DataFrame(r2Dict, index=['R-Squared', ])
        display(r2DF)

    display(mseDf)


def fit_and_eval_learners(predictions, predictions_test, data_generating_func):
    """
    :param predictions: data dictionary of predictions generated by causalml library
    :param predictions_test: data dictionary of predictions generated by causalml library, same models, used for testing the stacking function
    :param data_generating_func: name of the type of dataset
    :return: final_predictions: predicitons made using the ensemble weights
    """
    predictions_copy = copy.deepcopy(predictions)
    [predictions_copy.pop(key) for key in ['Actuals', 'generated_data']]

    # compare single learners on their own
    simple_model.multilayer_hist(predictions_copy, predictions['Actuals'], 121, xmin=-10, xmax=10, ymax=80)
    plt.title('Distribution of CATE Predictions \nby input algorithm:\n' + data_generating_func)
    plt.xlabel('Individual Treatment Effect (ITE/CATE)')
    plt.ylabel('number of observations')
    _ = plt.legend()

    # fit an ensemble using the predictions of the learners
    ens_model = do_stacking(predictions, predictions['Actuals'])

    predictions_test_copy = copy.deepcopy(predictions_test)
    [predictions_test_copy.pop(key) for key in ['Actuals', 'generated_data']]

    testdf = pd.DataFrame(predictions_test_copy, index=[np.arange(0, 1000), ])
    ens_params = ens_model.params

    final_predictions = np.dot(testdf, ens_model.params)

    simple_model.multilayer_hist({'ensemble': final_predictions}, predictions_test['Actuals'], 122, xmin=-10, xmax=10,
                                 ymax=80)
    plt.title('distribution of stacked \nCATE estimates:\n' + data_generating_func)
    plt.xlabel('Individual Treatment Effect (ITE/CATE)')
    plt.ylabel('number of observations')

    return final_predictions
